{"posts":[{"title":"一元二次方程组的通解","content":"对于一元二次方程组： {a1x+b1y=c1a2x+b2y=c2\\begin{cases} a_1x + b_1y = c_1\\\\ a_2x + b_2y = c_2 \\end{cases} {a1​x+b1​y=c1​a2​x+b2​y=c2​​ ","link":"https://zhongtianrui.github.io/post/yi-yuan-er-ci-fang-cheng-zu-de-tong-jie/"},{"title":"一元二次方程组的解的个数的判定","content":"对于一元二次方程 a1x+b1y=c1a2x+b2y=c2a_1x+b_1y=c_1\\\\ a_2x+b_2y=c_2 a1​x+b1​y=c1​a2​x+b2​y=c2​ 若 a1a2=b1b2\\frac{a_1}{a_2} \\not ={\\frac{b_1}{b_2}}a2​a1​​​=b2​b1​​，那么方程有唯一解。 若 a1a2=b1b2=c1c2\\frac{a_1}{a_2} ={\\frac{b_1}{b_2}} = \\frac{c_1}{c_2}a2​a1​​=b2​b1​​=c2​c1​​，那么方程有无数解。 若 a1a2=b1b2=c1c2\\frac{a_1}{a_2} ={\\frac{b_1}{b_2}} \\not = {\\frac{c_1}{c_2}}a2​a1​​=b2​b1​​​=c2​c1​​，那么方程无解。 ","link":"https://zhongtianrui.github.io/post/yi-yuan-er-ci-fang-cheng-zu-de-jie-de-ge-shu-de-pan-ding/"},{"title":"ST 表","content":"类似 dp，预处理的时候定义 dp[i][j] 为从 iii 开始的 2j2^j2j 个元素中的最大的。 得出 dpi,j=max⁡(dpi,j−1,dpi+2j−1,j−1)dp_{i,j} = \\max(dp_{i, j - 1}, dp_{i + 2 ^{j - 1}, j- 1})dpi,j​=max(dpi,j−1​,dpi+2j−1,j−1​)。 ##代码 #include &lt;bits/stdc++.h&gt; using namespace std; /* */ int n, m, a[1000005], dp[100005][25]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; dp[i][0] = a[i]; } for (int i = 1; i &lt;= 21; i ++) { for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; j ++) { dp[j][i] = max(dp[j][i - 1], dp[j + (1 &lt;&lt; (i - 1))][i - 1]); } } while (m --) { int l, r; cin &gt;&gt; l &gt;&gt; r; int c = __lg(r - l + 1); cout &lt;&lt; max(dp[l][c], dp[r - (1 &lt;&lt; c) + 1][c]) &lt;&lt; &quot;\\n&quot;; } return 0; } ","link":"https://zhongtianrui.github.io/post/st-biao/"},{"title":"随手记","content":"不等式（组）可以借助数轴来完成。 解含参一元一次不等式组的方法： 题目：是否存在常数 aaa 使得关于 xxx 的不等式 a(x−1)&gt;4x−3a(x - 1) &gt; 4x - 3a(x−1)&gt;4x−3 的解为 x&gt;2x &gt; 2x&gt;2？ 解： (a−4)x&gt;a−3(a - 4)x &gt; a - 3 (a−4)x&gt;a−3 由于 x&gt;2x &gt; 2x&gt;2 和上式的不等号方向相同，所以可以得出： a−4&gt;0a&gt;4a - 4 &gt; 0\\\\ a &gt; 4 a−4&gt;0a&gt;4 ","link":"https://zhongtianrui.github.io/post/sui-shou-ji/"},{"title":"加密算法","content":"明文：`action&quot;。 密钥为矩阵 AAA。 如： (1211)\\left ( \\begin{matrix} 1&amp; 2 \\\\ 1&amp; 1 \\\\ \\end{matrix} \\right ) (11​21​) 讲明文的每个单词转化为如下数字： a→1,b→2,…,z→26,A→27…a \\to 1, b \\to 2, \\dots , z \\to 26, A \\to 27 \\dots a→1,b→2,…,z→26,A→27… 后两两分为一组，写成列向量的形式。 (13),(209),(1514)\\left ( \\begin{matrix} 1 \\\\ 3 \\\\ \\end{matrix} \\right ) , \\left ( \\begin{matrix} 20 \\\\ 9 \\\\ \\end{matrix} \\right ) , \\left ( \\begin{matrix} 15 \\\\ 14 \\\\ \\end{matrix} \\right ) (13​),(209​),(1514​) 加密 对每组列向量变换为矩阵，并乘以 AAA。 将多组矩阵排开，变成 7,4,38,29,43,297, 4, 38, 29, 43, 297,4,38,29,43,29。 这个数组就是密文了。 解密 我们将密文分组，再将每个矩阵乘以 A−1A^{-1}A−1 就可以得到明文。 因为 BA×1÷A=BBA \\times 1 \\div A = BBA×1÷A=B，1÷A=A−11 \\div A = A^{-1}1÷A=A−1。 ","link":"https://zhongtianrui.github.io/post/jia-mi-suan-fa/"},{"title":"P2420 让我们异或吧 做题笔记","content":"题意：给定一个树，再给定两点，求这两点直接的路径的每条边的异或和。 思路 我们有 xxx ^ x=0x = 0x=0，所以可以得出结论：对于这个路径，我们可以一直往上到根，再回到最近公共祖先也行。 有了上面的结论，我们直接 dfs，求出根节点到每个节点的异或和，每次询问时直接输出 x→rootx \\to rootx→root ^ 1→y1 \\to y1→y 就行了。 拓展 当我们把异或和换成总和，那么我们发现之前的方法就没办法用了，所以我们可以照样预处理，定义 xxx 和 yyy 的最近公共祖先是 lll，f(x)=sum(1→x)f(x) = sum(1\\to x)f(x)=sum(1→x) 那么每次查询的答案就是 f(x)+f(y)−f(l)f(x) + f(y) - f(l)f(x)+f(y)−f(l)。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n, m; vector &lt;int&gt; e[100005], v[100005]; int s[1000005]; int vis[1000005]; void dfs(int i, int sum) { vis[i] = 1; s[i] = sum; for (int ii = 0; ii &lt; e[i].size(); ii ++) { if (vis[e[i][ii]] == 0) dfs(e[i][ii], sum ^ v[i][ii]); } } int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n - 1; i ++) { int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; e[x].push_back(y); v[x].push_back(z); e[y].push_back(x); v[y].push_back(z); } cin &gt;&gt; m; dfs(1, 0); while (m --) { int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; (s[x] ^ s[y]) &lt;&lt; &quot;\\n&quot;; } } ","link":"https://zhongtianrui.github.io/post/p2420-rang-wo-men-yi-huo-ba-zuo-ti-bi-ji/"},{"title":"助读笔记 71","content":"故事大意 曾子的妻子去市场，孩子一直哭。曾子的妻子哄骗说回来宰了猪吃。 但她回来后没有宰，曾子由此批评了她的妻子。 评价 曾子的妻子做的不对，她不应该哄骗孩子。 子不教，父母之过。 孩子如果长大后，很容易学着父母，容易出问题。 启发 我们对谁都应该诚实，不能因为弱小而欺骗。 ","link":"https://zhongtianrui.github.io/post/zhu-du-bi-ji-71/"},{"title":"日记 2023-12-3","content":"今天天气：☀️ 心情：☀️ 转 ⛅️ 早上，吃饭，吃了炒饭。 心情还可以，开始了学习 中午，吃饭，有点没胃口，没吃啥东西。 害怕等会会俄 qwq ps： 头图参数记录： x = 225 y = 125 文字大小 = 50 链接 = https://www.lddgo.net/image/text-to-image ","link":"https://zhongtianrui.github.io/post/ri-ji-2023-12-3/"},{"title":"[ABC313B] Who is Saikyo?","content":"题目链接 概括大意 给出一些人的关系，比如说 AiA_iAi​ 比 BiB_iBi​ 强，求出最强的人。 不等式的性质在这里也是适用的。 思路 第一眼：建一个有向无环图，dfs遍历，如果发现终点不同，那么说明答案不止一个，输出 -1，否则输出终点。 第二眼：统计出度，如果一个节点只有入度，没用出度，那么就是终点了，输出方式同上。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; /* */ int n, m; int chudu[1000005]; //出度 int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i ++) { int x, y; cin &gt;&gt; x &gt;&gt; y; chudu[y] ++; } vector &lt;int&gt; v; for (int i = 1; i &lt;= n; i ++) { if (chudu[i] == 0) v.push_back(i); } if (v.size() &gt; 1) cout &lt;&lt; -1; else cout &lt;&lt; v[0]; return 0; } ","link":"https://zhongtianrui.github.io/post/abc313b-who-is-saikyo/"},{"title":"since、for 和 ago 的区别","content":"since 表示从 xxx 开始，后面接时间节点。 for 是现在完成时或过去完成时，表示一段时间，后面接一段时间的长度。 现在完成时 指的是一件事，过去发生，还影响到了现在。 过去完成时 同理，指的是一件事，在过去的过去发生，影响到了过去。 ago 是一般过去时，指的是过去发生的事，没影响到其他时间。 ","link":"https://zhongtianrui.github.io/post/for-he-ago-de-qu-bie/"},{"title":"崭新的博客","content":"hi~ 我们的博客又回来了。 更新 更换为 Netlify 托管前端，更稳定，快速。 全部旧的文章更换，重启一个更好的开始。 评论系统部署了 Valine，更美观、快捷。 ","link":"https://zhongtianrui.github.io/post/zhan-xin-de-bo-ke/"}]}